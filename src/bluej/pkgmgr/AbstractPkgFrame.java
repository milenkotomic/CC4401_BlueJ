package bluej.pkgmgr;

import java.awt.EventQueue;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

import javax.swing.Action;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuItem;

import bluej.Config;
import bluej.collect.DataCollector;
import bluej.pkgmgr.actions.HelpAboutAction;
import bluej.pkgmgr.actions.PreferencesAction;
import bluej.pkgmgr.actions.QuitAction;
import bluej.pkgmgr.target.ClassTarget;
import bluej.pkgmgr.target.role.UnitTestClassRole;
import bluej.prefmgr.PrefMgrDialog;
import bluej.utility.Debug;
import bluej.utility.DialogManager;
import bluej.utility.FileUtility;
import bluej.utility.Utility;

public abstract class AbstractPkgFrame extends JFrame implements IPkgFrame{

	protected static AbstractPkgFrame recentFrame = null;
	protected static List<AbstractPkgFrame> frames = new ArrayList<AbstractPkgFrame>(); // of PkgMgrFrames
	
	private JLabel statusbar;
	  /*
     * The package that this frame is working on or null for the case where
     * there is no package currently being edited (check with isEmptyFrame())
     */
    protected Package pkg = null;
	
    /**
     * Gets the most recently used PkgMgrFrame
     * 
     * @return the PkgMgrFrame that currently has the focus
     */
    public AbstractPkgFrame getMostRecent()
    {
    	/*SI*/
        if (recentFrame != null) {
            return recentFrame;
        }
        
        AbstractPkgFrame[] allFrames = getAllFrames();

        // If there are no frames open, yet...
        if (allFrames.length < 1) {
            return null;
        }

        // Assume that the most recent is the first one. Not really the best
        // thing to do...
        AbstractPkgFrame mostRecent = allFrames[0];

        for (int i = 0; i < allFrames.length; i++) {
            if (allFrames[i].getFocusOwner() != null) {
                mostRecent = allFrames[i];
            }
        }

        return mostRecent;
    }
    
    /**
     * Returns an array of all PkgMgrFrame objects. It can be an empty array if
     * none is found.
     */
    public static AbstractPkgFrame[] getAllFrames()
    {
    	/*SI*/
        AbstractPkgFrame[] openFrames = new PkgMgrFrame[frames.size()];
        frames.toArray(openFrames);

        return openFrames;
    }
    
    /**
     * Return the project of the package shown by this frame.
     */
    public Project getProject()
    {
        return pkg == null ? null : pkg.getProject();
    }
    
    /**
     * Add a new menu item to a menu.
     */
    /*Luego se va a menu*/
    protected JMenuItem createMenuItem(Action action, JMenu menu)
    {
        JMenuItem item = menu.add(action);
        item.setIcon(null);
        return item;
    }
	
    /**
     * Called on (almost) every menu invocation to clean up.
     */
    public void menuCall()
    {
        if (!isEmptyFrame())
            pkg.setState(Package.S_IDLE);
        clearStatus();
    }
    
    /**
     * Return true if this frame is currently editing a package. A call to this
     * should bracket all uses of getPackage() and editor.
     */
    public boolean isEmptyFrame()
    {
        return pkg == null;
    }
    /*Se va a status bar*/
    public void clearStatus()
    {
       EventQueue.invokeLater(new Runnable() {
            public void run() {
                if (statusbar != null)
                    statusbar.setText(" ");
            }
        });
    }
    
    /**
     * Return true if this frame is editing a Java Micro Edition package.
     */
    public boolean isJavaMEpackage( )
    {
        if (pkg == null) return false;
        return pkg.getProject().isJavaMEProject();
    } 
    
    
    //public abstract AbstractPkgFrame getMostRecent();
    
    /**
     * Handle a "display about dialog" request generated by the OS
     */
    public void handleAbout()
    {
    	/*A abstract*/
        HelpAboutAction.getInstance().actionPerformed(getMostRecent());
    }
    
    /**
     * Handle a "show preferences" request generated by the OS
     */
    public void handlePreferences()
    {
    	/*A abstract*/
        PreferencesAction.getInstance().actionPerformed(getMostRecent());
    }
    
    /**
     * Handle a quite request generated by the OS
     */
    public void handleQuit()
    {
    	QuitAction.getInstance().actionPerformed(getMostRecent());
    }
      
        
    /**
     * About menu was chosen.
     */
    public void aboutBlueJ()
    {
    	AboutBlue about = new AboutBlue(this, bluej.Boot.BLUEJ_VERSION);
        about.setVisible(true);
    }

    /**
     * Preferences menu was chosen.
     */
    public void showPreferences( )
    {
        PrefMgrDialog.showDialog();
    }

    
    
    /**Opens an empty window. Action performed when the "New Window" button is pressed*/
    public void doOpenWindow(){
    	/*Crea nueva ventana vacia*/
    	PkgMgrFrame frame = PkgMgrFrame.createFrame();
    	frame.setLocation(0, 0);

    	/*Mostrar la ventana, una vez creada*/
    	frame.setVisible(true);
    }
       
    
    
    
    /*Metodos comunes a todos los tipos de ventana, los que aparezcan como abstractas 
     * son implementadas por cada tipo
     */
    
    public abstract void openPackage(Package pkg);
    public abstract boolean newProject(String dirName, boolean isJavaMEproject);
    //public abstract IPkgFrame findFrame(Package p);
    
    /**
     * Allow the user to select a directory into which we create a project.
     * @param isJavaMEproject   Whether this is a Java Micro Edition project or not.
     * @return true if the project was successfully created. False otherwise.
     */
    public boolean doNewProject( boolean isJavaMEproject )
    {
        String title = Config.getString( "pkgmgr.newPkg.title" );
        if ( isJavaMEproject )
            title = Config.getString( "pkgmgr.newMEpkg.title" );
                    
        File newnameFile = FileUtility.getDirName( this, title,
                 Config.getString( "pkgmgr.newPkg.buttonLabel" ), false, true );

        if (newnameFile == null)
            return false;

        if(newnameFile.exists()) {
            Debug.message("Attempt to create project with existing directory: " + newnameFile.getAbsolutePath());
            DialogManager.showErrorWithText(null, "directory-exists", newnameFile.getPath());
            return false;
        }
        else if(!newProject(newnameFile.getAbsolutePath(), isJavaMEproject)) {
            DialogManager.showErrorWithText(null, "cannot-create-directory", newnameFile.getPath());
            return false;
        }

        return true;
    }
    
    /**
     * Open a dialog that lets the user choose a project. The project selected
     * is opened in a frame.
     */
    public void doOpen()
    {
        File dirName = FileUtility.getPackageName(this);
       // PkgMgrFrame.doOpen(dirName, this);
    }

    /**
     * Open the project specified by 'projectPath'. Return false if not
     * successful. Displays a warning dialog if the opened project resides in
     * a read-only directory.
     */
    private boolean openProject(String projectPath)
    {
        Project openProj = Project.openProject(projectPath, this);
        if (openProj == null)
            return false;
        else {
            Package initialPkg = openProj.getPackage(openProj.getInitialPackageName());

          //IPkgFrame pmf = findFrame(initialPkg);

           //if (pmf == null) {
                if (isEmptyFrame()) {
              //      pmf = this;
                    openPackage(initialPkg);
                }
                else {
//                    pmf = createFrame(initialPkg);

            //        DialogManager.tileWindow(pmf, this);
                }
            }

            //pmf.setVisible(true);

            return true;
        }
    

    /**
     * Open a dialog that lets a user convert existing Java source into a BlueJ
     * project.
     * 
     * The project selected is opened in a frame.
     */
    public void doOpenNonBlueJ()
    {
        File dirName = FileUtility.getNonBlueJDirectoryName(this);

        if (dirName == null)
            return;

        File absDirName = dirName.getAbsoluteFile();
        
        // First confirm the chosen file exists
        if (! absDirName.exists()) {
            // file doesn't exist
            DialogManager.showError(this, "file-does-not-exist");
            return;
        }
        
        if (absDirName.isDirectory()) {
            // Check to make sure it's not already a project
            if (Project.isProject(absDirName.getPath())) {
                DialogManager.showError(this, "open-non-bluej-already-bluej");
                return;
            }
            
            // Try and convert it to a project
            if (! Import.convertNonBlueJ(this, absDirName))
                return;
            
            // then construct it as a project
            openProject(absDirName.getPath());
        }
        else {
            // Presumably it's an archive file
            openArchive(absDirName);
        }
    }
    
    /**
     * Open an archive file (jar or same contents with other extensions) as a
     * BlueJ project. The file contents are extracted, the containing directory
     * is then converted into a BlueJ project if necessary, and opened.
     */
    private boolean openArchive(File archive)
    {
        // Determine the output path.
        File oPath = Utility.maybeExtractArchive(archive, this);
        
        if (oPath == null)
            return false;
        
        if (Project.isProject(oPath.getPath())) {
            return openProject(oPath.getPath());
        }
        else {
            // Convert to a BlueJ project
            if (Import.convertNonBlueJ(this, oPath)) {
                return openProject(oPath.getPath());
            }
            else {
                return false;
            }
        }        
    }
    
  
    
    
}
